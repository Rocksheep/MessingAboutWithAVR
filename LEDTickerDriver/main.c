#define F_CPU 8000000

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#include "hc595_shift.h"

uint8_t text[] = {
	/*0x00, 0x00, 0xF4, 0x00, 0x00, //!*/
	/*0x00,*/
	/*0x84, 0xA4, 0xA4, 0xA4, 0xFC, //E [rev]*/
	/*0x00,*/
	/*0x00, 0x00, 0x00, 0x00, 0x00, //space*/
	/*0x00,*/
	/*0xFC, 0x20, 0x20, 0x20, 0xFC, //H*/
	/*0x00,*/
	/*0x7C, 0x90, 0X90, 0x90, 0x7C, //A*/
	/*0x00,*/
	/*0x78, 0x84, 0x84, 0x84, 0x84, //C*/
	/*0x00,*/
	/*0xFC, 0x30, 0x48, 0x84, 0x00, //K*/
	/*0x00,*/
	/*0xFC, 0xA4, 0xA4, 0xA4, 0x84, //E*/
	/*0x00,*/
	/*0xFC, 0x40, 0x30, 0x08, 0xFC, //N*/
	/*0x00,*/
	/*0x00, 0x00, 0x00, 0x00, 0x00, //space*/
	/*0x00,*/
	/*0x00, 0x84, 0xFC, 0x84, 0x00, //I*/
	/*0x00,*/
	/*0x48, 0xA4, 0xA4, 0xA4, 0x18, //S*/
	/*0x00,*/
	/*0x00, 0x00, 0x00, 0x00, 0x00, //space*/
	/*0x00,*/
	/*0x78, 0x84, 0x84, 0x84, 0x84, //C*/
	/*0x00,*/
	/*0x78, 0x84, 0x84, 0x84, 0x78, //O*/
	/*0x00,*/
	/*0x78, 0x84, 0x84, 0x84, 0x78, //O*/
	/*0x00,*/
	/*0xFC, 0x04, 0x04, 0x04, 0x04, //L*/
	/*0x00,*/
	/*0x00, 0x00, 0xF4, 0x00, 0x00, //!*/
	/*0x00,*/
	/*0x84, 0xA4, 0xA4, 0xA4, 0xFC //E [rev]*/

	0xFC, 0xA0, 0xA0, 0xB0, 0x4C, //R
	0x00,
	0xFC, 0xA4, 0xA4, 0xA4, 0x84, //E
	0x00,
	0xC0, 0x30, 0x0C, 0X30, 0xC0, //V
	0x00,
	0x48, 0xA4, 0xA4, 0xA4, 0x18, //S
	0x00,
	0xFC, 0xA0, 0xA0, 0xA0, 0x40, //P
	0x00,
	0x7C, 0x90, 0X90, 0x90, 0x7C, //A
	0x00,
	0x78, 0x84, 0x84, 0x84, 0x84, //C
	0x00,
	0xFC, 0xA4, 0xA4, 0xA4, 0x84 //E
};

volatile int16_t shiftIn = 0;

ISR(TIMER1_OVF_vect) {
	static int counter = 0;
	if(counter >= 3) {
		counter = 0;
		shiftIn += 1;
	}
	counter += 1;
}

void initTimer0();


int main() {

	hc595_init();
	initTimer0();

	int8_t shiftCounter = 0x00;

	int8_t row, charCol, curShift, curMaxShift;
	int16_t col;
	//revspace: 47 cols
	uint8_t textLength = 47;//198;

	//all output
	DDRD = 0xFF;
	DDRA = 0xFF;


	while(1) {
		if(shiftIn > 80 + textLength)
			shiftIn = 0;
		curMaxShift = shiftIn;
		for(row = 7; row >= 0; row--) {
			charCol = textLength; //word length
			PORTA = row;
			hc595_latchLow();
			for(col = 80 + textLength; col >= 0; col--){
				if(curMaxShift > col && charCol >= 0) {
					if(~text[charCol] & (1 << row))
						hc595_dataHigh();
					else
						hc595_dataLow();
					//hc595_dataLow();
					charCol -= 1;
					//if(charCol < 0)
					//	charCol = textLength;
				}
				else {
					hc595_dataHigh();
				}
				hc595_clk();
			}
			hc595_latchHigh();
			//shiftCounter += 1;
			//shiftCounter = ~shiftCounter;
		}

	}

}

void initTimer0() {
	//set the prescaler to 1
	TCCR1B |= (1 << CS10);

	//enable timer1 overflow
	TIMSK |= (1 << TOIE1);

	sei();
}

