#define F_CPU 8000000

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#include "hc595_shift.h"

/*volatile uint8_t text[] = {*/
	/*~0x7C, ~0x10, ~0x10, ~0x10, ~0x10, ~0x10, ~0x10, ~0x00, //T*/
	/*~0x7C, ~0x40, ~0x78, ~0x40, ~0x40, ~0x7C, ~0x00, ~0x00, //E*/
	/*//S*/
	/*~0x7C, ~0x10, ~0x10, ~0x10, ~0x10, ~0x10, ~0x10, ~0x00, //T*/
	/*~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, //[space]*/
	/*~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, //[space]*/
	/*~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, //[space]*/
	/*~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, //[space]*/
	/*~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, //[space]*/
	/*~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, //[space]*/
	/*~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00, ~0x00 //[space]*/
/*};*/

uint8_t text[] = {
	0xFC, 0xA0, 0xA0, 0xB0, 0x4C, //R
	0x00,
	0xFC, 0xA4, 0xA4, 0xA4, 0x84, //E
	0x00,
	0xC0, 0x30, 0x0C, 0X30, 0xC0, //V
	0x00,
	0x48, 0xA4, 0xA4, 0xA4, 0x18, //S
	0x00,
	0xFC, 0xA0, 0xA0, 0xA0, 0x40, //P
	0x00,
	0x7C, 0x90, 0X90, 0x90, 0x7C, //A
	0x00,
	0x78, 0x84, 0x84, 0x84, 0x84, //C
	0x00,
	0xFC, 0xA4, 0xA4, 0xA4, 0x84 //E
};

volatile uint8_t shiftIn = 0;

ISR(TIMER1_OVF_vect) {
	static uint8_t counter = 0;
	if(counter >= 780) {
		counter = 0;
		shiftIn += 1;
	}
	counter += 1;
}

void initTimer0();


int main() {

	hc595_init();
	//initTimer0();

	int8_t shiftCounter = 0x00;

	int8_t counter, charTest;

	//all output
	DDRD = 0xFF;
	DDRA = 0xFF;

	while(1) {
		for(counter = 7; counter >= 0; counter--) {
			PORTA = counter;
			hc595_latchLow();
			for(charTest = 47; charTest >= 0; charTest--){
				if(~text[charTest] & (1 << counter))
					hc595_dataHigh();
				else
					hc595_dataLow();
				hc595_clk();
			}
			hc595_latchHigh();
			//shiftCounter += 1;
			//shiftCounter = ~shiftCounter;
		}

	}

}

void initTimer0() {
	//set the prescaler to 1024
	TCCR1B |= (1 << CS12 | 1 << CS10);

	//enable timer1 overflow
	TIMSK |= (1 << TOIE1);

	sei();
}

